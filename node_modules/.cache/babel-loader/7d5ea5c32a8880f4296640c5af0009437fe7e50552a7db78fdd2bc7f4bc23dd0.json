{"ast":null,"code":"var _jsxFileName = \"/Users/guilhermelemospimentel/Documents/Trybe/projetos/sd-028-b-project-trivia-react-redux/src/components/Questions.js\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport './Questions.css';\nimport { connect } from 'react-redux';\nimport { UPDATE_SCORE, actionHandled, assertionsNumber } from '../redux/actions';\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Questions extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      indexQuestions: 0,\n      arrayQuestion: [],\n      answered: false,\n      mixedQuestions: [],\n      timer: 30\n    };\n    this.questionsFetch = async () => {\n      const recoveredQuestion = localStorage.getItem('token');\n      const url = await (await fetch(`https://opentdb.com/api.php?amount=5&token=${recoveredQuestion}`)).json();\n      const invalidToken = 3;\n      if (url.response_code === invalidToken) {\n        const {\n          history\n        } = this.props;\n        localStorage.removeItem('token');\n        history.push('/');\n      }\n      this.setState({\n        arrayQuestion: url.results\n      });\n      return url.results;\n    };\n    this.questionRender = arrayQuestion => {\n      const {\n        indexQuestions\n      } = this.state;\n      console.log('indexQuestions', indexQuestions);\n      // console.log(arrayQuestion);\n      if (arrayQuestion.length > 0) {\n        const correctRender = {\n          dataTestid: 'correct-answer',\n          correctRender: true,\n          questionText: arrayQuestion[indexQuestions].correct_answer,\n          color: 'green',\n          difficulty: arrayQuestion[indexQuestions].difficulty\n        };\n        const incorrectRender = arrayQuestion[indexQuestions].incorrect_answers.map((answer, index) => ({\n          dataTestid: `wrong-answer-${index}`,\n          correctRender: false,\n          questionText: answer,\n          color: 'red',\n          difficulty: arrayQuestion[indexQuestions].difficulty\n        }));\n        const questionsAll = [...incorrectRender, correctRender];\n        // console.log(questionsAll);\n        this.mixQuestions(questionsAll);\n      }\n    };\n    this.mixQuestions = questions => {\n      const magicNumber = 0.5;\n      const mixedQuestions = questions.sort(() => magicNumber - Math.random());\n      // console.log(mixedQuestions);\n      this.setState({\n        mixedQuestions\n      });\n    };\n    this.setTimer = () => {\n      const {\n        timer\n      } = this.state;\n      if (timer > 0) {\n        this.setState(prevState => ({\n          timer: prevState.timer - 1\n        }));\n      } else {\n        this.setState({\n          answered: true\n        });\n      }\n    };\n    this.handleClickAnswer = (id, difficulty) => {\n      const {\n        dispatch\n      } = this.props;\n      const {\n        timer\n      } = this.state;\n      const scoresParameter = 10;\n      const hardParameter = 3;\n      const MediumParameter = 2;\n      let multiplier = 1;\n      this.setState({\n        answered: true,\n        timer: 0\n      });\n      if (difficulty === 'hard') {\n        multiplier = hardParameter;\n      }\n      if (difficulty === 'medium') {\n        multiplier = MediumParameter;\n      }\n      if (id === 'correct-answer') {\n        const scoresValue = scoresParameter + timer * multiplier;\n        dispatch(actionHandled(UPDATE_SCORE, scoresValue));\n        dispatch(assertionsNumber(1));\n      }\n      // Nao altera nada quando a resposta e errada, pelo menos por enquanto\n    };\n    this.handleClickNext = () => {\n      const {\n        arrayQuestion,\n        indexQuestions\n      } = this.state;\n      const {\n        history\n      } = this.props;\n      const limitOfQuestions = 5;\n      if (indexQuestions < limitOfQuestions - 1) {\n        this.setState({\n          answered: false,\n          timer: 30,\n          indexQuestions: indexQuestions + 1\n        });\n        this.questionRender(arrayQuestion);\n      }\n      // } else if (indexQuestions >= limitOfQuestions - 1) {\n      //   this.questionRender(arrayQuestion);\n      // }\n\n      const lengthIndexOfQuestions = 3;\n      if (indexQuestions > lengthIndexOfQuestions) {\n        history.push('/feedback');\n      }\n    };\n  }\n  async componentDidMount() {\n    const arrayQuestion = await this.questionsFetch();\n    this.questionRender(arrayQuestion);\n    const timerReload = 1000;\n    setInterval(() => this.setTimer(), timerReload);\n    console.log(arrayQuestion);\n  }\n  componentDidUpdate() {\n    // Nao entendi 100% se o cypress quer que seja redirecionado logo apos repsonder a ultima pergunta ou apos clicar no Next depois disso\n    // const { history } = this.props;\n    // const {\n    //   indexQuestions,\n    //   answered,\n    // } = this.state;\n    // const indexLimit = 5;\n    // if (answered && (indexQuestions === indexLimit)) {\n    //   history.push('/feedback');\n    // }\n  }\n\n  // Separei a Requisicao a API do ComponentDidMount\n\n  render() {\n    const {\n      arrayQuestion,\n      indexQuestions,\n      answered,\n      mixedQuestions,\n      timer\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [arrayQuestion.length > 0 && /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          \"data-testid\": \"question-category\",\n          children: arrayQuestion[indexQuestions].category\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 173,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          \"data-testid\": \"question-text\",\n          children: arrayQuestion[indexQuestions].question\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 176,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true), /*#__PURE__*/_jsxDEV(\"div\", {\n        \"data-testid\": \"answer-options\",\n        children: arrayQuestion.length > 0 && mixedQuestions.map(a => /*#__PURE__*/_jsxDEV(\"button\", {\n          className: answered ? a.color : '',\n          \"data-testid\": a.dataTestid,\n          value: a.correct,\n          onClick: () => {\n            this.handleClickAnswer(a.dataTestid, a.difficulty);\n          },\n          disabled: answered,\n          children: a.questionText\n        }, a.questionText, false, {\n          fileName: _jsxFileName,\n          lineNumber: 185,\n          columnNumber: 15\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 182,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: timer\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 9\n      }, this), answered && /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          \"data-testid\": \"btn-next\",\n          onClick: () => {\n            this.handleClickNext();\n          },\n          children: \"Next\"\n        }, \"nextButton\", false, {\n          fileName: _jsxFileName,\n          lineNumber: 204,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 203,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 7\n    }, this);\n  }\n}\nQuestions.propTypes = {\n  fetchingQuestions: PropTypes.func,\n  history: PropTypes.shape({\n    push: PropTypes.func\n  })\n}.isRequired;\nexport default connect()(Questions);\n// so criei aqui pra ser renderizado no login","map":{"version":3,"names":["React","PropTypes","connect","UPDATE_SCORE","actionHandled","assertionsNumber","Questions","Component","state","indexQuestions","arrayQuestion","answered","mixedQuestions","timer","questionsFetch","recoveredQuestion","localStorage","getItem","url","fetch","json","invalidToken","response_code","history","props","removeItem","push","setState","results","questionRender","console","log","length","correctRender","dataTestid","questionText","correct_answer","color","difficulty","incorrectRender","incorrect_answers","map","answer","index","questionsAll","mixQuestions","questions","magicNumber","sort","Math","random","setTimer","prevState","handleClickAnswer","id","dispatch","scoresParameter","hardParameter","MediumParameter","multiplier","scoresValue","handleClickNext","limitOfQuestions","lengthIndexOfQuestions","componentDidMount","timerReload","setInterval","componentDidUpdate","render","category","question","a","correct","propTypes","fetchingQuestions","func","shape","isRequired"],"sources":["/Users/guilhermelemospimentel/Documents/Trybe/projetos/sd-028-b-project-trivia-react-redux/src/components/Questions.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Questions.css';\nimport { connect } from 'react-redux';\nimport { UPDATE_SCORE, actionHandled, assertionsNumber } from '../redux/actions';\n\nclass Questions extends React.Component {\n  state = {\n    indexQuestions: 0,\n    arrayQuestion: [],\n    answered: false,\n    mixedQuestions: [],\n    timer: 30,\n  };\n\n  async componentDidMount() {\n    const arrayQuestion = await this.questionsFetch();\n    this.questionRender(arrayQuestion);\n    const timerReload = 1000;\n    setInterval(() => this.setTimer(), timerReload);\n    console.log(arrayQuestion);\n  }\n\n  componentDidUpdate() {\n    // Nao entendi 100% se o cypress quer que seja redirecionado logo apos repsonder a ultima pergunta ou apos clicar no Next depois disso\n    // const { history } = this.props;\n    // const {\n    //   indexQuestions,\n    //   answered,\n    // } = this.state;\n    // const indexLimit = 5;\n    // if (answered && (indexQuestions === indexLimit)) {\n    //   history.push('/feedback');\n    // }\n  }\n\n  // Separei a Requisicao a API do ComponentDidMount\n  questionsFetch = async () => {\n    const recoveredQuestion = localStorage.getItem('token');\n    const url = await (await fetch(`https://opentdb.com/api.php?amount=5&token=${recoveredQuestion}`)).json();\n    const invalidToken = 3;\n    if (url.response_code === invalidToken) {\n      const { history } = this.props;\n      localStorage.removeItem('token');\n      history.push('/');\n    }\n    this.setState({\n      arrayQuestion: url.results,\n    });\n    return url.results;\n  };\n\n  questionRender = (arrayQuestion) => {\n    const { indexQuestions } = this.state;\n    console.log('indexQuestions', indexQuestions);\n    // console.log(arrayQuestion);\n    if (arrayQuestion.length > 0) {\n      const correctRender = {\n        dataTestid: 'correct-answer',\n        correctRender: true,\n        questionText: arrayQuestion[indexQuestions].correct_answer,\n        color: 'green',\n        difficulty: arrayQuestion[indexQuestions].difficulty,\n      };\n\n      const incorrectRender = arrayQuestion[indexQuestions].incorrect_answers\n        .map((answer, index) => ({\n          dataTestid: `wrong-answer-${index}`,\n          correctRender: false,\n          questionText: answer,\n          color: 'red',\n          difficulty: arrayQuestion[indexQuestions].difficulty,\n        }));\n      const questionsAll = [\n        ...incorrectRender,\n        correctRender,\n      ];\n      // console.log(questionsAll);\n      this.mixQuestions(questionsAll);\n    }\n  };\n\n  // Separei a logica que aleatoriza as questoes para ficar mais organizado\n  mixQuestions = (questions) => {\n    const magicNumber = 0.5;\n    const mixedQuestions = questions.sort(() => magicNumber - Math.random());\n    // console.log(mixedQuestions);\n    this.setState({\n      mixedQuestions,\n    });\n  };\n\n  setTimer = () => {\n    const { timer } = this.state;\n\n    if (timer > 0) {\n      this.setState((prevState) => ({\n        timer: prevState.timer - 1,\n      }));\n    } else {\n      this.setState({\n        answered: true,\n      });\n    }\n  };\n\n  handleClickAnswer = (id, difficulty) => {\n    const { dispatch } = this.props;\n    const { timer } = this.state;\n    const scoresParameter = 10;\n    const hardParameter = 3;\n    const MediumParameter = 2;\n    let multiplier = 1;\n\n    this.setState({\n      answered: true,\n      timer: 0,\n    });\n    if (difficulty === 'hard') {\n      multiplier = hardParameter;\n    }\n    if (difficulty === 'medium') {\n      multiplier = MediumParameter;\n    }\n\n    if (id === 'correct-answer') {\n      const scoresValue = scoresParameter + (timer * multiplier);\n      dispatch(actionHandled(UPDATE_SCORE, scoresValue));\n      dispatch(assertionsNumber(1));\n    }\n    // Nao altera nada quando a resposta e errada, pelo menos por enquanto\n  };\n\n  // Esta com delay, esta renderizando o novo texto da pergunta mas os botoes estao sendo rendererizados da pergunta anterior\n  handleClickNext = () => {\n    const { arrayQuestion, indexQuestions } = this.state;\n    const { history } = this.props;\n    const limitOfQuestions = 5;\n\n    if (indexQuestions < limitOfQuestions - 1) {\n      this.setState({\n        answered: false,\n        timer: 30,\n        indexQuestions: indexQuestions + 1,\n      });\n      this.questionRender(arrayQuestion);\n    }\n    // } else if (indexQuestions >= limitOfQuestions - 1) {\n    //   this.questionRender(arrayQuestion);\n    // }\n\n    const lengthIndexOfQuestions = 3;\n\n    if (indexQuestions > lengthIndexOfQuestions) {\n      history.push('/feedback');\n    }\n  };\n\n  render() {\n    const {\n      arrayQuestion,\n      indexQuestions,\n      answered,\n      mixedQuestions,\n      timer,\n    } = this.state;\n\n    return (\n      <div>\n\n        {arrayQuestion.length > 0 && (\n          <>\n            <p data-testid=\"question-category\">\n              {arrayQuestion[indexQuestions].category}\n            </p>\n            <p data-testid=\"question-text\">\n              {arrayQuestion[indexQuestions].question}\n            </p>\n          </>\n        ) }\n\n        <div data-testid=\"answer-options\">\n          {arrayQuestion.length > 0 && (\n            mixedQuestions.map((a) => (\n              <button\n                key={ a.questionText }\n                className={ answered ? a.color : '' }\n                data-testid={ a.dataTestid }\n                value={ a.correct }\n                onClick={ () => { this.handleClickAnswer(a.dataTestid, a.difficulty); } }\n                disabled={ answered }\n              >\n                {a.questionText}\n              </button>\n            ))\n          )}\n        </div>\n\n        <div>\n          {timer}\n        </div>\n        { answered && (\n          <div>\n            <button\n              key=\"nextButton\"\n              data-testid=\"btn-next\"\n              onClick={ () => { this.handleClickNext(); } }\n            >\n              Next\n            </button>\n          </div>\n        )}\n\n      </div>\n    );\n  }\n}\n\nQuestions.propTypes = {\n  fetchingQuestions: PropTypes.func,\n  history: PropTypes.shape({\n    push: PropTypes.func,\n  }),\n}.isRequired;\n\nexport default connect()(Questions);\n// so criei aqui pra ser renderizado no login\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}